#!/usr/bin/env python
# coding: utf-8
"""
watchnow.py

copyright norahiko
MIT Lisence

usage:
    # when c files modified, echo and run make command
    $ watchnow --c="*.c" --c="echo modified" --c="make"
    
    # set log-level
    $ watchnow --c="*.c" --log-level=DEBUG
    

"""
import sys
import os
import re
import time
import shlex
from subprocess import PIPE, Popen
from datetime import datetime, timedelta

import glob2
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

encoding = sys.stdout.encoding


class Logger(object):
    stderr = sys.stderr
    stdout = sys.stdout

    def __init__(self, level="INFO"):
        self.level = ["DEBUG", "INFO", "ERROR"].index(level.upper())

    def debug(self, message):
        if self.level <= 0:
            self.stdout.write(message)
            self.stdout.write("\n")

    def info(self, message):
        if self.level <= 1:
            self.stdout.write(message)
            self.stdout.write("\n")

    def error(self, message):
        if self.level <= 2:
            self.stderr.write(message)
            self.stderr.write("\n")

    def fail(self, command, output, error):
        if output:
            self.info(output)

        self.error("\x1b[31mError: `%s`" % command)
        self.error("vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\x1b[39m")
        self.error(error)
        self.error("\x1b[31m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\x1b[39m")

    def success(self, command, output):
        self.debug("command: `%s`" % command)
        self.info(output)


class Command(object):
    _instances = {}

    def __new__(cls, command):
        command = command.strip()
        if command not in cls._instances:
            cls._instances[command] = super(Command, cls).__new__(cls)
        return cls._instances[command]

    def __init__(self, command):
        command = command.strip()
        self.command = command
        self.last_executed = datetime(1, 1, 1)

    def run(self, filepath, files, interval):
        dirpath = os.path.dirname(filepath)
        cmd = self.command.replace("{dir}", dirpath)
        cmd = cmd.replace("{file}", filepath)
        cmd = cmd.replace("{files}", " ".join(files))
        return self.execute(cmd, interval)

    def execute(self, cmd, interval):
        if datetime.now() - self.last_executed < timedelta(seconds=interval):
            return (None, None, None)

        proc = Popen(cmd, shell=True, stdout=PIPE, stderr=PIPE)
        output, error = proc.communicate()

        self.last_executed = datetime.now()
        return (cmd, output.decode(encoding), error.decode(encoding))

    def __repr__(self):
        return self.command


class Task(object):
    def __init__(self, name, file_pattern):
        self.name = name
        self.file_pattern = file_pattern
        self.commands = []
        self.update_watching_files()

    def update_watching_files(self):
        self.watching_files = []
        self.watching_files_fullpath = []
        cwd = os.getcwd()

        for pattern in shlex.split(self.file_pattern):
            for path in glob2.glob(pattern):
                self.watching_files.append(path)
                self.watching_files_fullpath.append(os.path.join(cwd, path))


    def add_command(self, command):
        self.commands.append(Command(command))


    def __repr__(self):
        return "%s: [%s] => %s" %(self.name, self.file_pattern, " -> ".join(map(str, self.commands)))


class EventHandler(FileSystemEventHandler):
    def __init__(self, watcher):
        self.watcher = watcher

    def on_modified(self, event):
        path = event.src_path.decode(encoding)
        if self.is_ignored_file(path):
            return
        try:
            self.watcher.run_tasks(path)
        except Exception as e:
            sys.stderr.write(repr(e))
            raise

    def on_created(self, event):
        path = event.src_path.decode(encoding)
        if self.is_ignored_file(path):
            return
        self.watcher.update_watching_files()

    def is_ignored_file(self, path):
        f = os.path.basename(path)
        return f.startswith(".") or f.endswith("~") or f.endswith(".swp") or f == "4913"


class Cron(object):
    def __init__(self, seconds, command):
        self.interval = seconds
        self.command = Command(command)

    def run(self):
        return self.command.execute(self.command.command, self.interval)


class Watcher(object):
    option_pattern = re.compile(r"--([-\w]+)=")
    config = {
        "interval": 1,
        "delay": 0,
    }

    def __init__(self, options):
        self.tasks = []
        self.crons = []
        self.logger = Logger()

        self.init_tasks(options)

    def init_tasks(self, options):
        for option in options:
            name, value = self.split_option(option)
            if name is None:
                continue

            name = name.replace("-", "_")

            if name == "log_level":
                self.logger = Logger(value)
            elif name.isdigit():
                self.add_cron(int(name), value)
            elif name in self.config:
                self.config[name] = float(value)
            else:
                self.add_task(name, value)

    def add_task(self, name, value):
        for task in self.tasks:
            if task.name == name:
                task.add_command(value)
                break
        else:
            self.tasks.append(Task(name, value))

    def add_cron(self, interval, command):
        self.crons.append(Cron(interval, command))

    def split_option(self, option):
        match = self.option_pattern.match(option)
        if match is None:
            return (None, None)

        task_name = match.group(1)
        option_value = option[len(match.group(0)):]
        return task_name, option_value

    def update_watching_files(self):
        for task in self.tasks:
            task.update_watching_files()

    def log_command(self, cmd, output, error):
        if cmd is None:
            return
        self.logger.info("\n" + "-" * 10)

        if error:
            self.logger.fail(cmd, output, error)
        else:
            self.logger.success(cmd, output)


    def run_tasks(self, filepath):
        for task in self.tasks:
            if filepath in task.watching_files_fullpath:
                self.run_commands(task, filepath)

    def run_commands(self, task, filepath):
        if 0 < self.config["delay"]:
            time.sleep(self.config["delay"])

        for command in task.commands:
            result = command.run(filepath, task.watching_files, self.config["interval"])
            self.log_command(*result)

    def run_crons(self):
        for cron in self.crons:
            self.log_command(*cron.run())

    def watch(self, curdir):
        observer = Observer()
        observer.schedule(EventHandler(self), path=curdir, recursive=True)
        observer.start()

        try:
            while True:
                self.run_crons()
                observer.join(1.0)
        finally:
            observer.stop()



def main():
    watcher = Watcher(sys.argv[1:])
    watcher.watch(os.getcwd())


if __name__ == '__main__':
    main()
